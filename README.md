# matching
二部マッチングの問題となりそうなお題を見つけたので練習で実装してみる

以下のスライド内容を実装したい

- https://drmp.jp/algorithm

とりあえずは解法など探さず、スライドでみたまんまの操作をGoで書いてみる


## 書いてて見つけた発見・感想
- プチTDDの大切さ
    - 一回結構な量を書いたけど、関数に分けてなかったのと、
        テストコードを書いてなかったので、
        ダメな部分の切り分けデバッグが面倒になり、一から作り直したので、処理がわかるところから関数に書いていって、その都度テスト書いて動作を細かく補償していくプチTDDの大切さを学んだ。
- mapのvalueを探す
    - keyからvalueを取得するのは当たり前だけど、valueを検索する時にいちいちループ回さなきゃいけないのが面倒。調べてみたけどあんまり簡単にする方法はわからなかった。
- 当たり前だけど、適当に変数名決めたらバチが当たる。
    - 変数名をtmpMatchとかにして途中まで作ってしまったけど、どんどん後に引けなくなるんだよな。
- テスト書いてるとよくあるsliceやmapの型宣言省略
    - 正しく書いてくより簡潔に書いた方が読みやすいよね。
    - https://qiita.com/Hiraku/items/7c3da376d9948c76c5f5
- インスタンスの中に別インスタンスがあるときの複雑さ
    - Userインスタンスの中にあるDesiredRankはポインタ型のClinicをvalueにもつmapである。最初ポインタ型じゃなく、普通のClinic構造体でやってたんだけど、あれ、このClinicってオリジナルじゃなくてコピーだっけ？となり、本物の補償が欲しくなったので、ポインタ型に変更した。こういうインスタンスの中身を更新する際などに、よぎる不安が積み重なっていくと精神的によくないので、どこかで本物を補償していかないといけないよねという話。
- sliceからの要素の削除時は上書きできないか考える
    - sliceの指定要素を削除して、何か新しい要素を追加するとき、なんとか削除してから、appendしようと思って、削除方法を学んだけど、要素の順番を考慮しないなら、指定要素のインデックスを確認して、そのインデックスの位置に新しい要素を入れちゃった方が楽。
    - どうしても削除だけしたい場合は素直に特殊なappendか、copyを使う。
        - https://zenn.dev/mattn/articles/31dfed3c89956d
- aスライス{1, 2, 3, 4}、bスライス{2, 3}があり、bスライスの要素の中でaスライスの最も右にあるものを判定したいとき。
    - iとjの二重ループ書いてみるとなんとかわかるよ！
- ポインタ変数の代入で起こるpanicについて
    ```golang
    func XXX(u *User) {
        var a *User{}

        a = u // 代入するとpanicエラーが発生
    }
    ```
    ```golang
    func YYY(u *User) {
        a := &User{}

        a = u // これは問題ない
    }
    ```
- 構造体のフィールドに「構造体のポインタ変数がvalueとなるmap」を持たせて、さらに、そのvalueとなる構造体がフィールドに「構造体のポインタ変数がvalueとなるmap」を持っている場合、テストがすごく複雑になるし、ロジックもわかりにくくなる。これ設計が悪いかも。
```golang
type Clinic struct {
	ID          int
	Name        string
	DesiredRank []int   // 希望順位(ユーザーID)
	tmpMatch    []*User // 仮マッチリスト
	Limit       int     // 受け入れ人数限界
}

// User ユーザー
type User struct {
	ID          int
	Name        string
	DesiredRank map[int]*Clinic // 希望順位
}
```

## 残作業
- どこで処理を完了とするかの判定
- failedの単体テストパターン追加
- ユーザーとクリニックを別口から入力するパターン
    - Step1.標準入力
    - Step2.json
    - Step3.DB
- ユーザー登録とかクリニック登録をAPIにして、DBに情報を保存してよりアプリケーションぽくするのはまだこの先。
